/***********************************************************/

/* Shader author: Foxioo */
/* Version shader: 1.1 (18.10.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex

#ifdef GL_ES
 precision mediump float;
#endif
uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;
varying vec2 In;

void main(void)
{
	In = texCoord;
	gl_Position = projectionMatrix * transformMatrix * position;
}

//@End

/* ####################################################### */

//@Begin_fragment

#ifdef GL_ES
 precision mediump float;
#endif

varying vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Varibles */
/***********************************************************/

uniform float _Mixing;
uniform float _DotsTranparent;
uniform float _DotsCoverage;
uniform float _DotsSize;
uniform float _DotsAntialiasing;
uniform bool _Blending_Mode;
uniform bool _DotsInvertedPattern;
uniform bool _DotsInvertedColors;
uniform bool _Is_Pre_296_Build;

/************************************************************/
/* Main */
/************************************************************/

float Fun_FMod(float _Value, float _Denom)
{
    return _Value - _Denom * floor(_Value / _Denom);
}

float Fun_Quantize(float _Value, float _Steps)
{
    if (_Steps <= 0.0)  
        return step(0.5, _Value);
    else                
        return floor(_Value * _Steps + 0.5) / _Steps;
}

vec3 Fun_Quantize_3(vec3 _Value, float _Steps)
{
    return vec3(Fun_Quantize(_Value.r, _Steps),
                Fun_Quantize(_Value.g, _Steps),
                Fun_Quantize(_Value.b, _Steps));
}

float Fun_PatternDot(vec2 UV, float _Size, float _Lum)
{
    vec2 _UV_Res = UV / vec2(fPixelWidth, fPixelHeight);
    vec2 _Grid = _UV_Res / _Size;

    float _Row = floor(_Grid.y);
    if (Fun_FMod(_Row, 2.0) == 1.0) {   
        _Grid.x += 0.5;  
    }

    vec2 _Cell = fract(_Grid);

    float _InvPattern = _DotsInvertedPattern ? 1.0 : 0.0;
    float _Dist = abs(_InvPattern - length(_Cell - 0.5)) * _DotsCoverage;

    float _Render = _Lum;
    float _Result = smoothstep(_Render - _DotsAntialiasing, _Render + _DotsAntialiasing, _Dist);

    return 1.0 - _Result * _DotsTranparent;
}

vec2 Fun_RotationX(vec2 In, float _RotX)
{
    vec2 _Points = vec2(0.5, 0.5);
    vec2 _UV = In;
    float _RotX_Fix = _RotX * (3.14159265 / 180.0);

    mat2 rotMat = mat2(
        cos(_RotX_Fix), sin(_RotX_Fix),
        -sin(_RotX_Fix), cos(_RotX_Fix)
    );

    _UV = _Points + rotMat * (_UV - _Points);

    return _UV;
}

void main(void)
{
    vec2 In_Background = vec2(In.x, 1.0 - In.y);

    vec4 _Render_Texture = texture2D(imgTexture, In) * blendColor;
    vec4 _Render_Background = _Is_Pre_296_Build ? texture2D(bckgTexture, In_Background) : texture2D(bckgTexture, In);

    vec4 _Result = _Blending_Mode ? _Render_Background : _Render_Texture;
    vec4 _Render = _Result;

        float _K = 1.0 - max(_Result.r, max(_Result.g, _Result.b));     float _InvK = 1.0 - _K;
        float _C = _InvK > 0.001 ? (1.0 - _Result.r - _K) / _InvK : 0.0;
        float _M = _InvK > 0.001 ? (1.0 - _Result.g - _K) / _InvK : 0.0;
        float _Y = _InvK > 0.001 ? (1.0 - _Result.b - _K) / _InvK : 0.0;

            float _YellowDot    = Fun_PatternDot(Fun_RotationX(In,  0.0), _DotsSize, _Y);
            float _CyanDot      = Fun_PatternDot(Fun_RotationX(In, 15.0), _DotsSize, _C);
            float _MagentaDot   = Fun_PatternDot(Fun_RotationX(In, 75.0), _DotsSize, _M);
            float _BlackDot     = Fun_PatternDot(Fun_RotationX(In, 45.0), _DotsSize, _K);

                    vec3 _YellowRender    = mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0), _YellowDot);
                    vec3 _CyanRender      = mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 1.0, 1.0), _CyanDot);
                    vec3 _MagentaRender   = mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.0, 1.0), _MagentaDot);
                    vec3 _BlackRender     = mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 0.0), _BlackDot);

        _Result.rgb = _YellowRender * _CyanRender * _MagentaRender * _BlackRender;
        _Result.rgb = mix(_Render.rgb, abs(float(_DotsInvertedColors) - _Result.rgb), _Mixing);

    _Result.a = _Render_Texture.a;
    gl_FragColor = _Result;
}

//@End