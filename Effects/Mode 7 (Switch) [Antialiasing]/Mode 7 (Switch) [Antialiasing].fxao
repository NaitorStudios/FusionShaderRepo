/***********************************************************/

/* Shader author: Foxioo */
/* Version shader: 1.9 (08.11.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex

#ifdef GL_ES
 precision mediump float;
#endif
uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;
varying vec2 In;

void main(void)
{
    In = texCoord;
    gl_Position = projectionMatrix * transformMatrix * position;
}

//@End

/* ####################################################### */

//@Begin_fragment

#ifdef GL_ES
 precision mediump float;
#endif

#define RAD 0.0174532925

varying vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform vec4 blendColor;

/***********************************************************/
/* Variables */
/***********************************************************/

uniform float _PosX;
uniform float _PosY;
uniform float _PosZ;

uniform float _OffsetX;

uniform float _ScaleX;
uniform float _ScaleY;
uniform float _Scale;

uniform float _RotX;
uniform float _RotY;
uniform float _RotZ;

uniform float _Distortion;

uniform float _RotXPointX;
uniform float _RotXPointY;
uniform float _RotYPointX;
uniform float _RotYPointY;

uniform float _PosOffsetX;
uniform float _PosOffsetY;

uniform int _Looping_Mode;

uniform bool _Render_Sky;
uniform bool _Blending_Mode;

uniform bool _Is_Pre_296_Build;

/***********************************************************/
/* Mode 7 */
/***********************************************************/

vec2 Fun_Mode7(vec2 In)
{
    vec2 _UV = In;
    _UV.x += _OffsetX - 0.5;
    _UV /= (In.y * _Distortion) - 0.5;
    return _UV * _PosZ;
}

vec2 Fun_RotationX(vec2 In)
{
    vec2 _UV = vec2(In.x + _RotXPointX, In.y + _RotXPointY) * 0.5;
    float _RotX_Temp = _RotX * RAD;

    float _CosR = cos(_RotX_Temp);
    float _SinR = sin(_RotX_Temp);

    return vec2(
        _UV.x * _CosR + _UV.y * _SinR,
        -_UV.x * _SinR + _UV.y * _CosR
    );
}

vec2 Fun_RotationY(vec2 In)
{
    vec2 _UV = vec2(In.x + _RotYPointX, In.y + _RotYPointY);
    float _RotY_Temp = (_RotY - 180.0) * RAD;

    float _CosR = cos(_RotY_Temp);
    float _SinR = sin(_RotY_Temp);

    vec2 _OffsetUV = _UV - 0.5;

    return 0.5 + vec2(
        _OffsetUV.x * _CosR + _OffsetUV.y * _SinR,
        -_OffsetUV.x * _SinR + _OffsetUV.y * _CosR
    );
}

float Fun_Loop(float _UV, int _Mode)
{
    if(_Mode == 0)
        return fract(_UV);

    else if(_Mode == 1)
        return abs(fract(_UV / 2.0) * 2.0 - 1.0);

    else if(_Mode == 2)
        return clamp(_UV, 0.0, 1.0);

    else
        return _UV;
}

bool Fun_CheckEdge(float _UV, int _Mode) { return (_Mode == 3 && (_UV < 0.0 || _UV > 1.0)); }

ivec2 Fun_SetLoop(int _Looping)
{
    if(_Looping == 0)      return ivec2(0, 0);
    else if(_Looping == 1) return ivec2(1, 1);
    else if(_Looping == 2) return ivec2(2, 2);
    else if(_Looping == 3) return ivec2(3, 3);

    else if(_Looping == 4) return ivec2(1, 0);
    else if(_Looping == 5) return ivec2(2, 0);
    else if(_Looping == 6) return ivec2(3, 0);

    else if(_Looping == 7) return ivec2(0, 1);
    else if(_Looping == 8) return ivec2(2, 1);
    else if(_Looping == 9) return ivec2(3, 1);

    else if(_Looping == 10) return ivec2(0, 2);
    else if(_Looping == 11) return ivec2(1, 2);
    else if(_Looping == 12) return ivec2(3, 2);

    else if(_Looping == 13) return ivec2(0, 3);
    else if(_Looping == 14) return ivec2(1, 3);
    else if(_Looping == 15) return ivec2(2, 3);

    else return ivec2(2, 2);
}

/************************************************************/
/* Main */
/************************************************************/

void main(void)
{   
    vec2 In_Background = vec2(In.x, 1.0 - In.y);
    
    vec2 In_RotY;
    if(_Is_Pre_296_Build && _Blending_Mode)
        In_RotY = Fun_RotationY(In_Background);
    else
        In_RotY = Fun_RotationY(In);

    float _RotZ_Temp = _RotZ * RAD;
    
        vec2 _In_Old = In_RotY;
        vec2 _In_Mod = In_RotY;
        _In_Mod.y += _RotZ_Temp;
        
        vec2 _UV = Fun_Mode7(_In_Mod);
        vec2 _Pos = vec2(-_PosX, _PosY);
        vec2 _PosOffset = vec2(-_PosOffsetX, _PosOffsetY - 0.5);
        vec2 _Scale_Temp = (vec2(_ScaleX, _ScaleY)) * _Scale;
        
        _UV = Fun_RotationX(_UV);
        _UV -= _PosOffset;
        _UV *= _Scale_Temp;
        _UV -= _Pos - 0.5;
        
            ivec2 _Mode;
            _Mode = Fun_SetLoop(_Looping_Mode);
            vec2 _In_Orginal = _UV;
            
                _UV = vec2(
                    Fun_Loop(_UV.x, _Mode.x),
                    Fun_Loop(_UV.y, _Mode.y)
                );
    
    /* Rendering */
    vec4 _Render;
    if(!_Blending_Mode) { _Render = texture2D(imgTexture, _UV) * blendColor; }
    else { _Render = texture2D(bckgTexture, _UV); _Render.a = texture2D(imgTexture, In).a; }
    
        if(Fun_CheckEdge(_In_Orginal.x, _Mode.x) || Fun_CheckEdge(_In_Orginal.y, _Mode.y))  { _Render = vec4(0.0); }
        if(((_In_Old.y + _RotZ_Temp) * _Distortion) > 0.5 && !_Render_Sky)                  { _Render = vec4(0.0); }
    
    gl_FragColor = _Render;
}

//@End