// 3dPerspective_1_5a

//@Begin_vertex
#ifdef GL_ES
 precision mediump float;
#endif
uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;
varying vec2 textureCoordinate;

void main(void)
{
	textureCoordinate = texCoord;
	gl_Position = projectionMatrix * transformMatrix * position;
}
//@End
//@Begin_fragment
#ifdef GL_ES
 precision mediump float;
#endif
varying vec2 textureCoordinate;

uniform sampler2D imgTexture;
uniform sampler2D iRTexture;

uniform int iM;

uniform float fH;
uniform float fV;
uniform float fD;
uniform float fZ;

uniform vec4 cA;
uniform vec4 cD;

uniform float fDx;
uniform float fDy;
uniform float fDz;

uniform lowp vec4 blendColor;

uniform float fPixelWidth;
uniform float fPixelHeight;


// Define a helper function to rotate any vec3 vector about the X axis.
vec3 rotateX(vec3 vec, float ang) {
	return vec3(vec.x, (vec.y * cos(ang)) - (vec.z * sin(ang)), (vec.y * sin(ang)) + (vec.z * cos(ang)));
}

// Define a helper function to rotate any vec3 vector about the Y axis.
vec3 rotateY(vec3 vec, float ang) {
	return vec3((vec.x * cos(ang)) + (vec.z * sin(ang)), vec.y, (vec.z * cos(ang)) - (vec.x * sin(ang))); 
}

// Define a helper function to rotate any vec3 vector about the Z axis. This isn't used here, but I'm including it in case anyone wants to implement it themselves.
/*
vec3 rotateZ(vec3 vec, float ang) {
	return vec3((vec.x * cos(ang)) - (vec.y * sin(ang)), (vec.x * sin(ang)) + (vec.y * cos(ang)), vec.z);
}
*/

float fmod(float a, float b) {
	return a - (b * floor(a/b));
}

void main(void)
{
	// Convert the angles from degrees to radians.
	float dH = radians(fH);
	float dV = radians(fV);
		
	// Create a point "p" in 3D space from the 2D position of the current pixel. fPixelWidth and fPixelHeight are used to correct for non-square textures. Coordinates are relative to the centre of the texture.
	// Essentially, we're going to convert the 2D texture into a 3D plane, and then instead of rotating it, we'll move the camera around it.
	vec3 p = vec3((textureCoordinate.x - 0.5) / fPixelWidth, (textureCoordinate.y - 0.5) / fPixelHeight, 0.0);
		
	// Create another point "c" representing the camera, placed infront of the texture (along the X axis).
	vec3 c = vec3(0.0, 0.0, 0.0 - fD);
		
	// Set the origin (where the camera is aimed) to the centre of the texture.
	vec3 o = vec3(0.5 / fPixelWidth, 0.5 / fPixelHeight, 0.0);
		
	// Rotate "p" on the Y-axis and then X-axis, around the origin, and then move it to make its position relative to the original coordinate system again.
	p = rotateX(rotateY(p, dH), dV) + o;
		
	// Repeat the exact same process for the camera "c".
	c = rotateX(rotateY(c, dH), dV) + o;
	
	// Create a surface normal vector "u", and rotate it in the opposite direction, using the reverse order of operations (X axis first, then Y axis).
	vec3 u = rotateY(rotateX(vec3(0.0, 0.0, 1.0), -1.0 * dV), -1.0 * dH);
		
	// Find which side of the card is showing to the camera. Most of the complexity comes from the need to support any angle values, and not just those in the range -180 to +180 degrees.
	float cH = (fmod((fmod(fH, 360.0) + 450.0), 360.0));
	float cV = (fmod((fmod(fV, 360.0) + 450.0), 360.0));
	int f = 0;
	if (cH > 180.0) { f++; }
	if (cV > 180.0) { f = int(fmod(float(f + 1), 2.0)); }
		
	// Trace a line from the camera "c" to the pixel "p", and find the point along it where Z=0 (where it intersects the texture plane), as a proportion of the total distance between them.
	// eg. s=0 means the camera's position; s=1 means the pixel's position; 0.5 means halfway between the camera and the pixel.
	float s = (0.0 - c.z) / (p.z - c.z);
		
	// Use linear interpolation to find the X and Y coordinates at the point of intersection.
	vec3 t = mix(c, p, s);
		
	// Convert coordinaates back to texture units (ranging from 0-1, instead of pixels), and scale the image to avoid parts being cut off when the texture is rotated.
	vec2 xy = ((vec2(t.x * fPixelWidth, t.y * fPixelHeight) - 0.5) / fZ) + 0.5;
		
	// Create a directional light vector.
	vec3 n = vec3(fDx, fDy, fDz);
	
	// Discard pixels outside the card.
	if (xy.x < 0.0 || xy.y < 0.0 || xy.x > 1.0 || xy.y > 1.0) { discard; }
	
	// Sample the texture.
	vec4 outColor = vec4(0,0,0,0);
	if (f == 0) {
		outColor = texture2D(imgTexture, xy);
	} else {
		xy.x = (iM < 2) ? xy.x : 1.0 - xy.x;
		outColor = (iM == 0) ? texture2D(iRTexture, xy) : texture2D(imgTexture, xy);
		// If the reverse face is showing to the camera, reverse the light vector.
		n *= vec3(-1,-1,-1);
	}
	
	// Calculate the light received from the directional light.
	vec3 l = max(0.0, dot(normalize(u), normalize(n))) * cD.rgb;
	
	// Multiply the pixel's colour by the combined ambient and directional light.
	outColor.rgb *= (cA.rgb + l);
 
	outColor *= blendColor;

	gl_FragColor = outColor;
}
//@End