/***********************************************************/

/* Autor shader: Foxioo */
/* Version shader: 1.0 (28.11.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/***********************************************************/

//@Begin_vertex

#ifdef GL_ES
 precision mediump float;
#endif

uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;

varying vec2 In;

void main(void)
{
    In = texCoord;
    gl_Position = projectionMatrix * transformMatrix * position;
}

//@End

/***********************************************************/

//@Begin_fragment

#ifdef GL_ES
 precision mediump float;
#endif

varying vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Variables */
/***********************************************************/

uniform float xA;
uniform float yA;
uniform float xB;
uniform float yB;
uniform float xC;
uniform float yC;
uniform float xD;
uniform float yD;

/***********************************************************/
/* Main */
/***********************************************************/

const float _Error   = 1e-6;
const float _Range   = 0.001;
const float _Out     = -1.0;

float Fun_Quad_Dist(vec2 UV, vec2 A, vec2 B) { return (B.x - A.x) * (UV.y - A.y) - (B.y - A.y) * (UV.x - A.x); }

bool Fun_Quad_Vertex(vec2 UV, vec2 A, vec2 B, vec2 C, vec2 D)
{
    float _V1 = Fun_Quad_Dist(UV, A, B);
    float _V2 = Fun_Quad_Dist(UV, B, C);
    float _V3 = Fun_Quad_Dist(UV, C, D);
    float _V4 = Fun_Quad_Dist(UV, D, A);

    vec4 _Vertex = vec4(_V1, _V2, _V3, _V4);

        bool _IsPos = (_Vertex.x > 0.0 || _Vertex.y > 0.0 || _Vertex.z > 0.0 || _Vertex.w > 0.0);
        bool _IsNeg = (_Vertex.x < 0.0 || _Vertex.y < 0.0 || _Vertex.z < 0.0 || _Vertex.w < 0.0);
    
    return !(_IsPos && _IsNeg);
}

vec2 Fun_Quad(vec2 UV)
{
    vec2 A = vec2(xA, yA);
    vec2 B = vec2(xB, yB);
    vec2 C = vec2(xC, yC);
    vec2 D = vec2(xD, yD);
    
    if (!Fun_Quad_Vertex(UV, A, B, C, D))   return vec2(_Out, _Out);

        float a2 = xB - xA;
        float a3 = xD - xA;
        float a4 = xA - xB + xC - xD;

        float b2 = yB - yA;
        float b3 = yD - yA;
        float b4 = yA - yB + yC - yD;

            float aa = a4 * b3 - a3 * b4;
            float bb = a4 * yA - xA * b4 + a2 * b3 - a3 * b2 + UV.x * b4 - UV.y * a4;
            float cc = a2 * yA - xA * b2 + UV.x * b2 - UV.y * a2;

            float l = _Out;
            float m = _Out;

    if (abs(aa) < _Error)
    {
        if (abs(a2 * b3 - a3 * b2) < _Error)   return vec2(_Out, _Out);
            
        m = -cc / bb;
        float denom = a2 + a4 * m;

            if (abs(denom) < _Error)   return vec2(_Out, _Out);
            
        l = (UV.x - xA - a3 * m) / denom;
    }
    else
    {
        float det = bb * bb - 4.0 * aa * cc;
        if (det < 0.0)  return vec2(_Out, _Out);

        det = sqrt(det);
        
            float m1 = (-bb + det) / (2.0 * aa);
            float m2 = (-bb - det) / (2.0 * aa);
            
            float l1, l2;

                bool validUwU = false;
                bool validOwO = false;
        
        float denom1 = a2 + a4 * m1;

        if (abs(denom1) > _Error)
        {
            l1 = (UV.x - xA - a3 * m1) / denom1;

                vec2 _SuperUwUCheck = vec2(       	l1 >= -_Range && l1 <= 1.0 + _Range,
                                                	m1 >= -_Range && m1 <= 1.0 + _Range     );

                            validUwU = (_SuperUwUCheck.x != 0.0 && _SuperUwUCheck.y != 0.0);
            
            if (validUwU) { l = l1; m = m1; }
        }
        
        float denom2 = a2 + a4 * m2;

        if (abs(denom2) > _Error)
        {
            l2 = (UV.x - xA - a3 * m2) / denom2;
            
                vec2 _SuperOwOCheck = vec2(       	l2 >= -_Range && l2 <= 1.0 + _Range,
                                                  	m2 >= -_Range && m2 <= 1.0 + _Range     );

                            validOwO = (_SuperOwOCheck.x != 0.0 && _SuperOwOCheck.y != 0.0);
            
            if (validOwO)
            {
                if (validUwU)
                {
                    vec2 sol1 = vec2(l1, m1);
                    vec2 sol2 = vec2(l2, m2);
                    
                    if (distance(sol2, vec2(0.5)) < distance(sol1, vec2(0.5)))  l = l2; m = m2;
                }
                else { l = l2;  m = m2; }
            }
        }
        
        if (!validUwU && !validOwO)    return vec2(_Out, _Out);
    }
    
            vec2 _SuperAwACheck = vec2(       	l >= -_Range && l <= 1.0 + _Range,
                                                m >= -_Range && m <= 1.0 + _Range     );
    
                        if (_SuperAwACheck.x != 0.0 && _SuperAwACheck.y != 0.0) return clamp(vec2(l, m), vec2(0.0), vec2(1.0));
    
    return vec2(_Out, _Out);
}

/*
vec2 Fun_Quad(vec2 UV)
{
    float a = (xA - UV.x) * (yB - UV.y) - (xB - UV.x) * (yA - UV.y);
    float b = (xB - UV.x) * (yC - UV.y) - (xC - UV.x) * (yB - UV.y);
    float c = (xC - UV.x) * (yD - UV.y) - (xD - UV.x) * (yC - UV.y);
    float d = (xD - UV.x) * (yA - UV.y) - (xA - UV.x) * (yD - UV.y);

    if (sign(a)==sign(b) && sign(b)==sign(c) && sign(c)==sign(d))
    {
        float a1 = xA;
        float a2 = xB - xA;
        float a3 = xD - xA;
        float a4 = xA - xB + xC - xD;

        float b1 = yA;
        float b2 = yB - yA;
        float b3 = yD - yA;
        float b4 = yA - yB + yC - yD;

        float aa = a4 * b3 - a3 * b4;
        float bb = a4 * b1 - a1 * b4 + a2 * b3 - a3 * b2 + UV.x * b4 - UV.y * a4;
        float cc = a2 * b1 - a1 * b2 + UV.x * b2 - UV.y * a2;

            float eps = 1e-6;
            float m;

                if (abs(aa) < eps) { m = -cc / bb; }
                else
                {
                    float det = sqrt(bb*bb - 4.0*aa*cc);
                    m = (-bb + det) / (2.0 * aa);
                }

        float denom = a2 + a4 * m;
        float l = (UV.x - a1 - a3 * m) / denom;

        return vec2(l, m);
    }
    else return vec2(-1.0);
}
*/


void main(void)
{
    vec2 _In = Fun_Quad(In);
    float _Border = (_In.x <= 0.0 || _In.x >= 1.0 || _In.y <= 0.0 || _In.y >= 1.0) ? 0.0 : 1.0;

    vec4 _Render_Texture = texture2D(imgTexture, _In) * blendColor;
    _Render_Texture.a *= _Border;

    gl_FragColor = _Render_Texture;
}

//@End