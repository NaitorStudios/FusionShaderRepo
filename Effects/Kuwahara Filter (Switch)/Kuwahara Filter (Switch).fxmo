/***********************************************************/

/* Shader author: Foxioo */
/* Version shader: 1.2 (18.10.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex
//version_####

uniform mat3 transformMatrix;
uniform mat3 projectionMatrix;
uniform mat3 objectMatrix;
uniform mat3 textureMatrix;

in vec2 position;
out vec2 In;
void main()
{
    vec3 pos = vec3(position, 1.0);
    In = (textureMatrix * pos).xy;
    gl_Position = vec4(projectionMatrix * transformMatrix * objectMatrix * pos, 1.0);
}
//@End

/* ####################################################### */

//@Begin_fragment
//version_####

#ifdef GL_ES
    #if defined(GL_FRAGMENT_PRECISION_HIGH) || defined(GL_OES_standard_derivatives)
        #define HIGH_PRECISION_SUPPORTED
    #endif
#else
    #define HIGH_PRECISION_SUPPORTED    
#endif

#ifdef HIGH_PRECISION_SUPPORTED
    precision highp float;
#else
    precision mediump float;
#endif

in vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Varibles */
/***********************************************************/

uniform float _Mixing;
uniform float _SegmentSize;

uniform bool _Blending_Mode;
uniform bool _Is_Pre_296_Build;

/************************************************************/
/* Main */
/************************************************************/

float Fun_Lum(vec3 _Render) { return (0.2126 * _Render.r + 0.7152 * _Render.g + 0.0722 * _Render.b); }

vec4 Fun_Kuwahara(vec2 UV, sampler2D _Sampler)
{
    const int _R = 4;
    
    vec4 _SumColor0 = vec4(0.0);    vec4 _SumColor1 = vec4(0.0);    vec4 _SumColor2 = vec4(0.0);    vec4 _SumColor3 = vec4(0.0);
    float _SumLum0 = 0.0;             float _SumLum1 = 0.0;             float _SumLum2 = 0.0;              float _SumLum3 = 0.0;
    float _SumLumSq0 = 0.0;           float _SumLumSq1 = 0.0;           float _SumLumSq2 = 0.0;            float _SumLumSq3 = 0.0;
    float _Count0 = 0.0;              float _Count1 = 0.0;              float _Count2 = 0.0;               float _Count3 = 0.0;

    for (int _Y = -_R; _Y <= _R; _Y++)
    {
        for (int _X = -_R; _X <= _R; _X++)
        {
            vec2 _Off = vec2(float(_X) * fPixelWidth, float(_Y) * fPixelHeight) * _SegmentSize;
            vec4 _Render = texture(_Sampler, UV + _Off);
            vec4 _Col = _Render;  
            float _Lum = Fun_Lum(_Render.rgb);

            int _R = int((min(sign(float(_X)), 0.0) + 1.0) + max(0.0, sign(float(_Y))) * 2.0);

            if (_R == 0) {
                _SumColor0 += _Col;
                _SumLum0 += _Lum;
                _SumLumSq0 += _Lum * _Lum;
                _Count0 += 1.0;
            } 

            else if (_R == 1) {
                _SumColor1 += _Col;
                _SumLum1 += _Lum;
                _SumLumSq1 += _Lum * _Lum;
                _Count1 += 1.0;
            }

            else if (_R == 2) {
                _SumColor2 += _Col;
                _SumLum2 += _Lum;
                _SumLumSq2 += _Lum * _Lum;
                _Count2 += 1.0;
            } 
            
            else if (_R == 3) {
                _SumColor3 += _Col;
                _SumLum3 += _Lum;
                _SumLumSq3 += _Lum * _Lum;
                _Count3 += 1.0;
            }
        }
    }

        vec4 _Mean0 = _SumColor0 / _Count0;
        float _E0 = _SumLum0 / _Count0;
        float _P0 = _SumLumSq0 / _Count0;
        float _Var0 = max(0.0, _P0 - _E0 * _E0);

        vec4 _Mean1 = _SumColor1 / _Count1;
        float _E1 = _SumLum1 / _Count1;
        float _P1 = _SumLumSq1 / _Count1;
        float _Var1 = max(0.0, _P1 - _E1 * _E1);

        vec4 _Mean2 = _SumColor2 / _Count2;
        float _E2 = _SumLum2 / _Count2;
        float _P2 = _SumLumSq2 / _Count2;
        float _Var2 = max(0.0, _P2 - _E2 * _E2);

        vec4 _Mean3 = _SumColor3 / _Count3;
        float _E3 = _SumLum3 / _Count3;
        float _P3 = _SumLumSq3 / _Count3;
        float _Var3 = max(0.0, _P3 - _E3 * _E3);

    vec4 _BestMean = _Mean0;
    float _MinVar = _Var0;
    
        if (_Var1 < _MinVar) {
            _BestMean = _Mean1;
            _MinVar = _Var1;
        }

        if (_Var2 < _MinVar) {
            _BestMean = _Mean2;
            _MinVar = _Var2;
        }

        if (_Var3 < _MinVar) {
            _BestMean = _Mean3;
        }

    return _BestMean;
}

out vec4 fragColor;
void main(void)
{
    vec2 In_Background = vec2(In.x, 1.0 - In.y);

    vec4 _Render_Texture = texture(imgTexture, In) * blendColor;
    vec4 _Render_Background = _Is_Pre_296_Build ? texture(bckgTexture, In_Background) : texture(bckgTexture, In);

        vec4 _Render_Kuwahara;
        vec4 _Result;

        if(_Blending_Mode == false)
        {
            _Result = _Render_Texture;
            _Render_Kuwahara = Fun_Kuwahara(In, imgTexture) * blendColor;
        }
        else
        {
            _Result = _Render_Background;
            _Render_Kuwahara = _Is_Pre_296_Build ? Fun_Kuwahara(In_Background, bckgTexture) : Fun_Kuwahara(In, bckgTexture);
        }
    
    _Result = mix(_Result, _Render_Kuwahara, _Mixing);
    _Result.a *= _Render_Texture.a;

    fragColor = _Result;
}
//@End