/***********************************************************/

/* Autor shader: Foxioo */
/* Version shader: 1.0 (29.12.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex
//version_####

uniform mat3 transformMatrix;
uniform mat3 projectionMatrix;
uniform mat3 objectMatrix;
uniform mat3 textureMatrix;

in vec2 position;
out vec2 In;
void main()
{
    vec3 pos = vec3(position, 1.0);
    In = (textureMatrix * pos).xy;
    gl_Position = vec4(projectionMatrix * transformMatrix * objectMatrix * pos, 1.0);
}
//@End

/* ####################################################### */

//@Begin_fragment
//version_####

#ifdef GL_ES
    #if defined(GL_FRAGMENT_PRECISION_HIGH) || defined(GL_OES_standard_derivatives)
        #define HIGH_PRECISION_SUPPORTED
    #endif
#else
    #define HIGH_PRECISION_SUPPORTED    
#endif

#ifdef HIGH_PRECISION_SUPPORTED
    precision highp float;
#else
    precision mediump float;
#endif

in vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Varibles */
/***********************************************************/

uniform float _Mixing;
uniform float _ReflectionMixing;
uniform float _ReflectionCut;
uniform vec4 _ColorMul;
uniform vec4 _ColorAdd;
uniform float _SafeAlphaMixing;
uniform float _SafeAlphaTransition;
uniform float _SafeAlphaPower;
uniform sampler2D _Texture_NormalMap;
uniform float _NormalMapX;
uniform float _NormalMapY;
uniform float _NormalMapStrength;
uniform float _NormalMapScaleX;
uniform float _NormalMapScaleY;
uniform sampler2D _Texture_Overlay;
uniform float _OverlayMixing;
uniform float _OverlayAddition;
uniform float _OverlayX;
uniform float _OverlayY;
uniform float _OverlayScaleX;
uniform float _OverlayScaleY;
uniform float _Line;
uniform vec4 _ColorLine;
uniform float _LineMixing;
uniform float _LineAmbient;
uniform float _LineAmbientMixing;
uniform float _PointX;
uniform float _PointY;
uniform float _RotX;
uniform bool _X;
uniform bool _Y;
uniform bool _Is_Pre_296_Build;

/************************************************************/
/* Main */
/************************************************************/

vec2 Fun_RotationX(vec2 In)
{
    vec2 _Points = vec2(_PointX, _PointY);
    vec2 _UV = In;
    float _RotX_Fix = _RotX * (3.14159265 / 180.0);

    mat2 _Mat = mat2(
        cos(_RotX_Fix), sin(_RotX_Fix),
        -sin(_RotX_Fix), cos(_RotX_Fix)
    );

    _UV = _Points + _Mat * (_UV - _Points);

    return _UV;
}

out vec4 fragColor;
void main(void)
{
    vec2 In_Background = _Is_Pre_296_Build ? vec2(In.x, 1.0 - In.y) : In;

    vec2 In_Rot = Fun_RotationX(In);
    
    float _Fix = mix(1.0, 1.0 - (clamp(abs(In_Rot.y - _SafeAlphaTransition) * 2.0 * (abs(0.5 - _SafeAlphaTransition) * _SafeAlphaPower), 0.0, 1.0)), _SafeAlphaMixing);

    vec4 _Render_Texture = texture(imgTexture, In) * blendColor;

    vec3 _Render_Normal = normalize(texture(_Texture_NormalMap, fract(In + vec2(_NormalMapX , _NormalMapY)) * vec2(_NormalMapScaleX, _NormalMapScaleY)).rgb * 2.0 - 1.0);
    vec2 _Offset = _Render_Normal.xy * _NormalMapStrength;

    vec4 _Render_Overlay = texture(_Texture_Overlay, fract(In + vec2(_OverlayX, _OverlayY) + _Offset) * vec2(_OverlayScaleX, _OverlayScaleY));

        vec4 _Result =  texture(bckgTexture, In_Background);

            vec4 _Reflect = texture(bckgTexture, fract(vec2(abs(float(_X) - In_Background.x) + _Offset.x, abs(float(_Y) - In_Background.y) + _Offset.y)));

                if(In_Rot.y > _ReflectionCut - _Offset.y) 
                {
                    _Result = mix(_Result, _Reflect, _ReflectionMixing);
                    _Result.rgb = _Result.rgb * _ColorMul.rgb + _ColorAdd.rgb;
                    _Result.rgb += clamp((1.0 - ((In_Rot.y - _ReflectionCut + _Offset.y) * _LineAmbient)) * _LineAmbientMixing * _ColorLine.rgb, 0.0, 1.0);

                    _Result.rgb = mix(_Result.rgb, mix(_Render_Overlay.rgb, _Render_Overlay.rgb + _Result.rgb, _OverlayAddition), _OverlayMixing * _Render_Overlay.a);

                    if(In_Rot.y < _ReflectionCut - _Offset.y + _Line) _Result.rgb += _ColorLine.rgb * _LineMixing;
                }

                _Result.rgb = mix(_Render_Texture.rgb, _Result.rgb, _Mixing);
        _Result.a = _Render_Texture.a;

    fragColor = _Result;
}
//@End