// CRT

//@Begin_vertex
//version_####
in vec2 position;

uniform mat3 projectionMatrix;
uniform mat3 transformMatrix;
uniform mat3 objectMatrix;
uniform mat3 textureMatrix;

out vec2 textureCoordinate;

void main()
{
    vec3 pos = vec3(position, 1.0);
    textureCoordinate = (textureMatrix * pos).xy;
    gl_Position = vec4(projectionMatrix * transformMatrix * objectMatrix * pos, 1.0);
}
//@End
//@Begin_fragment
//version_####
#ifdef GL_ES
    #if defined(GL_FRAGMENT_PRECISION_HIGH) || defined(GL_OES_standard_derivatives)
        #define HIGH_PRECISION_SUPPORTED
    #endif
#else
    #define HIGH_PRECISION_SUPPORTED    
#endif

#ifdef HIGH_PRECISION_SUPPORTED
    precision highp float;
#else
    precision mediump float;
#endif
in vec2 textureCoordinate;

uniform float inputW;
uniform float inputH;
uniform float outputW;
uniform float outputH;
uniform float phase;
uniform float distortion;
uniform float inputGamma;
uniform float outputGamma;

uniform sampler2D imgTexture;
uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

out vec4 fragColor;

#define TEX2D(c) pow(texture(imgTexture, (c)), vec4(inputGamma))
#define FIX(c)   max(abs(c), vec4(0.001));
#define PI 3.141592653589

vec2 rubyTextureSize;
vec2 rubyInputSize;
vec2 rubyOutputSize;

vec4 scanlineWeights(float dist, vec4 color)
{
	vec4 wid = 2.0 + 2.0 * pow(color, vec4(4.0));
	vec4 weights = vec4(dist * 3.333333);
	return (0.51 * exp(-pow(weights * sqrt(2.0 / wid), wid)) / (0.18 + 0.06 * wid));
}

void main(void)
{
	rubyTextureSize = 1.0/vec2(fPixelWidth, fPixelHeight);

	rubyInputSize = rubyTextureSize * vec2(inputW,inputH);
	rubyOutputSize = rubyTextureSize * vec2(outputW,outputH);

	vec2 one = 1.0 / rubyTextureSize;

	vec2 coord = textureCoordinate * (rubyTextureSize / rubyInputSize);
	vec2 cc = coord - 0.5;
	float dist = dot(cc, cc) * distortion;				
	vec2 xy = (coord + cc * (1.0 + dist) * dist) * rubyInputSize / rubyTextureSize;


	vec2 uv_ratio = fract(xy * rubyTextureSize) - 0.5;

	xy = (floor(xy*rubyTextureSize) + 0.5)/rubyTextureSize;

	vec4 coeffs = PI * vec4(1.0 + uv_ratio.x, uv_ratio.x, 1.0 - uv_ratio.x, 2.0 - uv_ratio.x);

	coeffs = FIX(coeffs);
	coeffs = 2.0 * sin(coeffs) * sin(coeffs / 2.0) / (coeffs * coeffs);

	// Normalize
	coeffs /= dot(coeffs, vec4(1.0));

	vec4 col1 = clamp(coeffs.x * TEX2D(xy + vec2(-one.x, 0.0))   + coeffs.y * TEX2D(xy) + coeffs.z * TEX2D(xy + vec2(one.x, 0.0)) + coeffs.w * TEX2D(xy + vec2(2.0 * one.x, 0.0)), vec4(0.0), vec4(1.0));
	vec4 col2 = clamp(coeffs.x * TEX2D(xy + vec2(-one.x, one.y)) + coeffs.y * TEX2D(xy + vec2(0.0, one.y)) + coeffs.z * TEX2D(xy + one) + coeffs.w * TEX2D(xy + vec2(2.0 * one.x, one.y)), vec4(0.0), vec4(1.0));

	vec4 weights1 = scanlineWeights(abs(uv_ratio.y) , col1);
	vec4 weights2 = scanlineWeights(1.0 - uv_ratio.y, col2);
	vec3 mul_res  = (col1 * weights1 + col2 * weights2).rgb;

	float mod_factor = textureCoordinate.x * rubyOutputSize.x * rubyTextureSize.x / rubyInputSize.x;

	vec3 dotMaskWeights = mix(
      	vec3(1.05, 0.75, 1.05),
      	vec3(0.75, 1.05, 0.75),
      	floor(mod(mod_factor, 2.0))
  	);

	mul_res *= dotMaskWeights;
    mul_res = pow(mul_res, vec3(1.0 / (2.0 * inputGamma - outputGamma)));

	vec4 color = vec4(mul_res, 1.0)*blendColor;

	fragColor = color; //gl_FragColor
}
//@End