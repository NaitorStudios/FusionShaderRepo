/***********************************************************/

/* Autor shader: Foxioo */
/* Version shader: 1.0 (22.12.2025) */
/* My GitHub: https://github.com/FoxiooOfficial */

/***********************************************************/

/* ####################################################### */

//@Begin_vertex

#ifdef GL_ES
 precision mediump float;
#endif
uniform mat4 transformMatrix;
uniform mat4 projectionMatrix;

attribute vec4 position;
attribute vec2 texCoord;
varying vec2 In;

void main(void)
{
	In = texCoord;
	gl_Position = projectionMatrix * transformMatrix * position;
}

//@End

/* ####################################################### */

//@Begin_fragment

#ifdef GL_ES
 precision mediump float;
#endif

varying vec2 In;

/***********************************************************/
/* Samplers */
/***********************************************************/

uniform sampler2D imgTexture;
//uniform sampler2D bckgTexture;

uniform lowp vec4 blendColor;
uniform float fPixelWidth;
uniform float fPixelHeight;

/***********************************************************/
/* Varibles */
/***********************************************************/

uniform float _Mixing;
uniform float _FraqMul;
uniform float _Seed;
uniform float _Time;
uniform float _Hertz;
uniform float _OffsetX_Pb;
uniform float _OffsetY_Pb;
uniform float _OffsetX_Pr;
uniform float _OffsetY_Pr;
uniform float _Phase;
//uniform bool _Is_Pre_296_Build;

/************************************************************/
/* Main */
/************************************************************/

vec4 Fun_GetColor(vec2 In, sampler2D _Texture)
{
    return texture2D(_Texture, In);
}

vec4 Fun_Interpolation(vec2 In, float _Segm, sampler2D _Texture, float _Smoothness)
{
    vec2 _In_Segment = floor(In * _Segm) / _Segm;
    vec2 _In_Segment_Next = (floor(In * _Segm) + 1.0) / _Segm;
    
    vec2 _UV = fract(In * _Segm);

        vec4 _Render_0X = Fun_GetColor(_In_Segment, _Texture);
        vec4 _Render_1X = Fun_GetColor(vec2(_In_Segment_Next.x, _In_Segment.y), _Texture);
            
            vec4 _Render_X = mix(_Render_0X, _Render_1X, smoothstep(0.0, _Smoothness, _UV.x));


        vec4 _Render_0Y = Fun_GetColor(vec2(_In_Segment.x, _In_Segment_Next.y), _Texture);
        vec4 _Render_1Y = Fun_GetColor(_In_Segment_Next, _Texture);
       
            vec4 _Render_Y = mix(_Render_0Y, _Render_1Y, smoothstep(0.0, _Smoothness, _UV.x));

    return mix(_Render_X, _Render_Y, smoothstep(0.0, _Smoothness, _UV.y));
}

vec3 Fun_Sharp_Ex(sampler2D _Sampler, vec2 _In, vec3 _Color, float _Sharpness_Size)
{
    vec3 _Result_Sharpness = 5.0 * _Color - (
                texture2D(_Sampler, _In + (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Sampler, _In - (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Sampler, _In + (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Sampler, _In - (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight)))
            ).rgb;

    return _Color - _Result_Sharpness * 0.1;
}

float Fun_Sharp(sampler2D _Sampler, vec2 _In, vec3 _Color, float _Sharpness_Size)
{
    vec3 _Result_Sharpness = 5.0 * _Color - (
                texture2D(_Sampler, _In + (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Sampler, _In - (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Sampler, _In + (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight))) +
                texture2D(_Sampler, _In - (_Sharpness_Size * vec2(fPixelWidth, fPixelHeight)))
            ).rgb;

    return (_Color.r + _Color.g + _Color.b) / 3.0 * 2.0 - (_Result_Sharpness.r + _Result_Sharpness.g + _Result_Sharpness.b) / 3.0;
}

float Fun_Rand(vec2 _UV)
{
    return fract(sin(dot(_UV, vec2(12.9898, 78.233))) * 43758.5453);
}

float Fun_FMod(float _Value, float _Denom)
{
    return _Value - _Denom * floor(_Value / _Denom);
}

void main(void)
{
    vec2 In_Background = In;
    In_Background.x -= Fun_FMod(In.y + _Time, fPixelHeight * 1125.0 / (_Hertz * -10.0 + 1125.0)) * fPixelWidth * _Phase * _Mixing;

    vec4 _Render_Texture = texture2D(imgTexture, In) * blendColor;
    //vec4 _Render_Background = _Is_Pre_296_Build ? texture2D(bckgTexture, In_Background) : texture2D(bckgTexture, In);

        const float _Div = 576.0;
        vec4 _Result_Pb = Fun_Interpolation(In_Background + vec2(_OffsetX_Pb * fPixelWidth, _OffsetY_Pb * fPixelHeight), _Div, imgTexture, 1.25);
        vec4 _Result_Pr = Fun_Interpolation(In_Background + vec2(_OffsetX_Pr * fPixelWidth, _OffsetY_Pr * fPixelHeight), _Div, imgTexture, 1.25);
        vec4 _Result = texture2D(imgTexture, In_Background);

        const float _Kr = 0.299;
        const float _Kg = 0.587;
        const float _Kb = 0.114;

        float _Y = _Kr * _Result.r + _Kg * _Result.g + _Kb * _Result.b;
        float _Pb = -0.168736 * _Result_Pb.r - 0.331264 * _Result_Pb.g + 0.5 * _Result_Pb.b;
        float _Pr = 0.5 * _Result_Pr.r - 0.418688 * _Result_Pr.g - 0.081312 * _Result_Pr.b;

            /* Multiplex */
            float _Omega = 2.0 * 3.14159265359 * (-85842.936 * _Hertz + 8725765.55);

                        float _Chroma_1 = _Pb * cos((_Omega * _FraqMul)) + _Pr * sin((_Omega * _FraqMul));
                        float _Chroma_2 = _Pb * cos((_Omega * _FraqMul) - 2.0) + _Pr * sin((_Omega * _FraqMul) - 2.0);
                        float _Chroma_3 = _Pb * cos((_Omega * _FraqMul) + 2.0) + _Pr * sin((_Omega * _FraqMul) + 2.0);

                /* Demultiplex */
                float _PbFix = (( _Chroma_2 * cos((_Omega * _FraqMul) - 2.0)) + ( _Chroma_1 * cos((_Omega * _FraqMul))) + ( _Chroma_3 * cos((_Omega * _FraqMul) + 2.0))) / 3.0;
                float _PrFix = (( _Chroma_2 * sin((_Omega * _FraqMul) - 2.0)) + ( _Chroma_1 * sin((_Omega * _FraqMul))) + ( _Chroma_3 * sin((_Omega * _FraqMul) + 2.0))) / 3.0;

                float _Edge = Fun_Sharp(imgTexture, In_Background, _Result.rgb, 1.0);
                _Y += (sin((In.x - In.y) * 10000.0 * _Edge       + _Time) * _Edge)   * 0.04;
                _PbFix += (sin((In.x + In.y) * 1000000.0 * _Edge + _Time) * _Edge) * 0.04;
                _PrFix += (cos((In.x + In.y) * 1000000.0 * _Edge + _Time) * _Edge) * 0.04;

            /* Meow RGB */
            float _R = _Y + 1.402 * _PrFix;
            float _G = _Y - 0.344136 * _PbFix - 0.714136 * _PrFix;
            float _B = _Y + 1.772 * _PbFix;

            vec3 _Render = Fun_Sharp_Ex(imgTexture, In_Background, vec3(_R, _G, _B), 1.0 - _Y);
            //_Render = mix(_Render, _Render.r * _Render.g * _Render.b, 0.35); 

           float _Rand = Fun_Rand(vec2(In.x + In.y + _Seed)) * _Edge;
                _Render.r += abs(sin(_Rand * 5345435.0 + _Time) * _Edge * _Y) * pow(_Y, 5.0);
                _Render.g += abs(sin(_Rand * 1204358.0 + _Time) * _Edge * _Y) * pow(_Y, 5.0);
                _Render.b += abs(cos(_Rand * 7568234.0 + _Time) * _Edge * _Y) * pow(_Y, 5.0);

                _Result.rgb = mix(_Result.rgb, _Render, _Mixing);
        _Result.a = _Render_Texture.a;

    gl_FragColor = _Result;
}
//@End